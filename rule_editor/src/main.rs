#![cfg_attr(
    all(not(debug_assertions), target_os = "windows"),
    windows_subsystem = "windows"
)]

mod models;
mod web_server;

use dotenvy::from_filename;
use sqlx::postgres::PgPoolOptions;
use sqlx::{Pool, Postgres};
use std::env;
use std::sync::Arc;
use std::time::Duration;
use std::io::Write;

#[derive(Clone)]
pub struct AppState {
    pub pool: Arc<Pool<Postgres>>,
    pub openai_client: async_openai::Client<async_openai::config::OpenAIConfig>,
}

#[tokio::main]
async fn main() {
    // CLIãƒ¢ãƒ¼ãƒ‰ã®ãƒã‚§ãƒƒã‚¯
    let args: Vec<String> = env::args().collect();
    
    if args.len() > 1 {
        match args[1].as_str() {
            "export" => {
                run_export_mode().await;
                return;
            }
            "web" => {
                run_web_mode().await;
                return;
            }
            _ => {}
        }
    }

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§Webãƒ¢ãƒ¼ãƒ‰ã‚’èµ·å‹•
    run_web_mode().await;
}


async fn run_export_mode() {
    // .env ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
    let workspace_env = format!(
        "{}/.env",
        env::var("CARGO_WORKSPACE_DIR").unwrap_or_default()
    );
    let env_paths = [
        ".env",
        "../.env",
        "../../.env",
        workspace_env.as_str(),
    ];

    for path in &env_paths {
        if std::path::Path::new(path).exists() {
            from_filename(path).ok();
            break;
        }
    }

    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶š
    let db_url = {
        let host = env::var("DB_HOST").unwrap_or_else(|_| "192.168.56.10".to_string());
        let port = env::var("DB_PORT").unwrap_or_else(|_| "5432".to_string());
        let user = env::var("DB_USER").unwrap_or_else(|_| "wix".to_string());
        let password = env::var("DB_PASSWORD").unwrap_or_else(|_| "wix".to_string());
        let db_name = env::var("DB_NAME").unwrap_or_else(|_| "wixdb".to_string());
        format!(
            "postgres://{}:{}@{}:{}/{}",
            user, password, host, port, db_name
        )
    };

    let pool = PgPoolOptions::new()
        .max_connections(5)
        .acquire_timeout(Duration::from_secs(5))
        .connect(&format!("{db_url}?connect_timeout=5"))
        .await
        .expect("Failed to connect to database");

    let pool = Arc::new(pool);

    // ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
    let state = AppState {
        pool: pool.clone(),
        openai_client: async_openai::Client::new(),
    };

    // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ç›´æ¥ä½¿ç”¨ã—ã¦ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
    match export_patterns_direct(&state).await {
        Ok(code) => {
            // ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãå‡ºã—
            let output_path = "shared/feature/src/generated_patterns.rs";
            let mut file = std::fs::File::create(output_path)
                .expect("Failed to create output file");
            file.write_all(code.as_bytes())
                .expect("Failed to write to file");
            println!("Successfully exported patterns to {}", output_path);
        }
        Err(e) => {
            eprintln!("Failed to export patterns: {}", e);
            std::process::exit(1);
        }
    }
}

async fn export_patterns_direct(state: &AppState) -> Result<String, String> {
    let pool = &state.pool;
    
    let query = r#"
        SELECT id, keyword, pattern, features, positive_examples, 
               negative_examples, created_at, updated_at, is_active
        FROM wix_rule_pattern
        WHERE is_active = true
        ORDER BY created_at DESC
    "#;
    
    let patterns = sqlx::query_as::<_, models::rule_pattern::RulePattern>(query)
        .fetch_all(pool.as_ref())
        .await
        .map_err(|e| format!("Failed to fetch patterns: {}", e))?;
    
    let mut output = String::from("// Auto-generated by rule_editor\n");
    output.push_str("// ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯è‡ªå‹•ç”Ÿæˆã•ã‚Œã¦ã„ã¾ã™ã€‚ç›´æ¥ç·¨é›†ã—ãªã„ã§ãã ã•ã„ã€‚\n\n");
    
    // detect_pattern! ãƒã‚¯ãƒ­ã‚’ä½¿ã£ãŸå½¢å¼ã§å‡ºåŠ›
    for pattern in patterns {
        let features = pattern.features_as_vec();
        let features_str = features
            .iter()
            .map(|f| format!("CardFeature::{}", f))
            .collect::<Vec<_>>()
            .join(", ");
        
        output.push_str(&format!(
            "detect_pattern![r\"{}\", {}], // {}\n",
            pattern.pattern.replace("\"", "\\\""),
            features_str,
            pattern.keyword
        ));
    }
    
    Ok(output)
}

async fn run_web_mode() {
    // .env ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
    let workspace_env = format!(
        "{}/.env",
        env::var("CARGO_WORKSPACE_DIR").unwrap_or_default()
    );
    let env_paths = [
        ".env",
        "../.env",
        "../../.env",
        workspace_env.as_str(),
    ];

    for path in &env_paths {
        if std::path::Path::new(path).exists() {
            from_filename(path).ok();
            break;
        }
    }

    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶š
    let db_url = {
        let host = env::var("DB_HOST").unwrap_or_else(|_| "192.168.56.10".to_string());
        let port = env::var("DB_PORT").unwrap_or_else(|_| "5432".to_string());
        let user = env::var("DB_USER").unwrap_or_else(|_| "wix".to_string());
        let password = env::var("DB_PASSWORD").unwrap_or_else(|_| "wix".to_string());
        let db_name = env::var("DB_NAME").unwrap_or_else(|_| "wixdb".to_string());
        format!(
            "postgres://{}:{}@{}:{}/{}",
            user, password, host, port, db_name
        )
    };

    let pool = PgPoolOptions::new()
        .max_connections(5)
        .acquire_timeout(Duration::from_secs(5))
        .connect(&format!("{db_url}?connect_timeout=5"))
        .await
        .expect("Failed to connect to database");

    let pool = Arc::new(pool);

    // OpenAI ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®åˆæœŸåŒ–
    let openai_config = async_openai::config::OpenAIConfig::new()
        .with_api_key(env::var("OPENAI_API_KEY").unwrap_or_default());
    let openai_client = async_openai::Client::with_config(openai_config);

    let app_state = AppState {
        pool,
        openai_client,
    };

    let app = web_server::create_router(app_state);
    
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3030")
        .await
        .expect("Failed to bind to port 3030");
    
    println!("ğŸš€ Rule Editor web server starting at http://localhost:3030");
    println!("Use Ctrl+C to stop the server");
    
    axum::serve(listener, app)
        .await
        .expect("Server failed to start");
}